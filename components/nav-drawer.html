<template for="NavDrawer">
  <link rel="stylesheet" href="../components/common.css">
  <style>
  /**
    For nav drawer
   
    https://material.io/guidelines/patterns/navigation-drawer.html#navigation-drawer-specs
  */
  a-nav-drawer ~ #blocker {
    position: fixed;
    background-color: #000;
    left: 0;
    right: 0;
    bottom: 0;
    opacity: .5;
    top: 0;
    z-index: 13;
    display: none;
  }
  a-nav-drawer {
    background-color: var(--theme-text-primary);
    box-shadow: var(--theme-shadow-3dp);
    color: var(--theme-primary);
    display: block;
    height: 100%; 
    left: 0;
    max-width: 320px;
    overflow: auto;
    position: fixed;
    top: 0;
    width: calc(100vw - var(--theme-height-app-bar));
    z-index: 16;
  }
  a-nav-drawer[visible] {
    left: 0;
    transform: translateX(0);
    visibility: visible;
    transition: var(--theme-animation-in);
  }
  a-nav-drawer:not([visible]) {
    left: -241px;
    transform: translateX(0);
    visibility: hidden;
    transition: var(--theme-animation-out);
  }

  a-nav-drawer hr, 
  a-nav-drawer .divider {
    display: block;
    margin: 4px 0px;
    height: 1px;
    border: 1px solid #ccc;
    border-width: 0 0 1px 0;
  }
  </style>
  <div id="container">
    <div id="blocker"></div>
    <div id="drawer">
      <slot></slot>
    </div>
  </div>
</template>

<script>
  // it will only reference the element while it's initially being processe
  var thisScript = document.currentScript;

  class NavDrawer extends HTMLElement {
    constructor() {
      super();
      let template = thisScript.ownerDocument.querySelector('template[for=NavDrawer]');
      let style = template.content.querySelector('style').cloneNode(true);
      style.setAttribute('id', 'a-nav-drawer-style');
      (!document.querySelector('#a-nav-drawer')) && this.insertBefore(style, this.firstChild);
      this.observeAttrChange('visible', this._show);
      this.blockerEl = this._addBlockerEl();
    }

    connectedCallback() {}
    disconnectedCallback() {}

    observeAttrChange(attrNames, callback) {
      var observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          if (mutation.type === 'attributes' && ([].concat(attrNames)).includes(mutation.attributeName)) {
            let newVal = mutation.target.getAttribute(mutation.attributeName);
            callback.apply(this, [mutation.attributeName, newVal]);
          }
        });
      });
      observer.observe(this, {attributes: true});
      return observer;
    }

    _addBlockerEl() {
      let blockerEl = document.createElement('div');
      blockerEl.setAttribute('id', 'blocker');
      blockerEl.addEventListener('click', () => {
        this.removeAttribute('visible');
        this._show();
      });
      this.parentElement.insertBefore(blockerEl, this.nextSibling);
      return blockerEl;
    }

    _show() {
      let visible = this.getAttribute('visible') !== null;
      document.body.style.overflow = visible ? 'hidden' : '';
      this.blockerEl.style.display = visible ? 'block' : 'none';
    }

  }
  
  customElements.define('a-nav-drawer', NavDrawer);
</script>
</script>